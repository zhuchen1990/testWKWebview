{
  "name": "TestWKWebViewDemo",
  "tagline": "",
  "body": "# MyTest\r\nThis is a project that test the ThirdPlatform  APIs\r\n\r\n* WKWebView\r\n* KingFisher\r\n* Chart\r\n\r\n\r\n##WKWebView\r\n###引言\r\n说到WKWebView，自我感觉的确很强大，不仅加载速度提升了，与js交互功能也越来强大了，这里就来写写自己在使用过程中的一些心得\r\n\r\n###使用\r\n使用过UIWebView的朋友对WkWebView的API应该也会比较熟悉，两者方法名很相似，苹果方面并没有改变太多，所以用起来也比较顺手,本人使用的是swift，下面代码也以swift为主。\t\r\n####初始化\r\n```\r\nlet conf = WKWebViewConfiguration()\r\n        wkWebView = WKWebView(frame: self.view.frame,configuration: conf)\r\n        wkWebView.loadRequest(NSURLRequest(URL: NSURL(string: \"http://www.baidu.com\")!))\r\n         wkWebView.UIDelegate = self\r\n        wkWebView.navigationDelegate = self\r\n        self.view.addSubview(wkWebView)\r\n     \r\n```\r\n注意的有以下几点\t\r\n1. 这里设置了WKWebView两个重要的代理UIDelegate和navigationDelegate，前者处理网页上一些弹出框的显示样式，后者处理网页加载时的逻辑，页面导航等。\t\r\n2. WKWebView都有一个配置策略，WKWebViewConfiguration关系网页的js交互功能，后面将详细介绍\r\n\r\n####UIDelegate\r\n```\r\n\r\nfunc webView(webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: () -> Void) {\r\n        let av = UIAlertController(title: \"alert\", message: message, preferredStyle: .Alert)\r\n        let ac = UIAlertAction(title: \"sure\", style: .Default) { (action) in\r\n            completionHandler()\r\n        }\r\n        av.addAction(ac)\r\n        self.presentViewController(av, animated: true, completion: nil)\r\n    }\r\n      \r\n    func webView(webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: (Bool) -> Void) {\r\n        \r\n        let av = UIAlertController(title: \"confirm\", message: message, preferredStyle: .Alert)\r\n        let ac = UIAlertAction(title: \"sure\", style: .Default) { (action) in\r\n            completionHandler(true)\r\n        }\r\n        let cancel = UIAlertAction(title: \"cancel\", style: .Cancel, handler: {(action) in\r\n            completionHandler(false)\r\n        })\r\n        av.addAction(ac)\r\n        av.addAction(cancel)\r\n        self.presentViewController(av, animated: true, completion: nil)\r\n\r\n    }\r\n    \r\n    func webView(webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: (String?) -> Void) {\r\n        let av = UIAlertController(title: \"prompt\", message: prompt, preferredStyle: .Alert)\r\n        let ac = UIAlertAction(title: \"sure\", style: .Default) { (action) in\r\n            let content = av.textFields?.first?.text\r\n            completionHandler(content)\r\n        }\r\n        let cancel = UIAlertAction(title: \"cancel\", style: .Cancel, handler: {(action) in\r\n            completionHandler(nil)\r\n        })\r\n        av.addTextFieldWithConfigurationHandler { (textField) in\r\n            textField.text = defaultText\r\n        }\r\n        \r\n        av.addAction(ac)\r\n        av.addAction(cancel)\r\n        self.presentViewController(av, animated: true, completion: nil)\r\n    }\r\n```\r\n这几个方法不是必须实现的，如果实现了这些方法，表明网页如果调用一些弹出框的时候如：alert，confirm，prompt会以系统原生的样式进行显示。\r\n\r\n####WKNavigationDelegate\r\n1.开始加载页面内容时就会回调此代理方法，与UIWebView的didStartLoad功能相当。\t\r\n\r\n```\r\nfunc webView(webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {\r\n    }\r\n```\r\n2.加载完成的回调\t\r\n\r\n```\r\nfunc webView(webView: WKWebView, didFinishNavigation navigation: WKNavigation!) {\r\n        self.title = webView.title\r\n    }\r\n```\r\n3.如果我们需要处理在重定向时\t\t\r\n\r\n```\r\nfunc webView(webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {\r\n  print(__FUNCTION__)\r\n}\r\n```\r\n4.我们终止页面加载\t\r\n\r\n```\r\nfunc webViewWebContentProcessDidTerminate(webView: WKWebView) {\r\n    print(__FUNCTION__)\r\n}\r\n```\r\n5.决定是否允许导航响应，如果不允许就不会跳转到该链接的页面。\r\n\r\n\t\r\n```\r\nfunc webView(webView: WKWebView, decidePolicyForNavigationResponse navigationResponse: WKNavigationResponse, decisionHandler: (WKNavigationResponsePolicy) -> Void) {\r\n    print(__FUNCTION__)\r\n    decisionHandler(.Allow)\r\n}\r\n```\t\r\n\r\n6.如果我们的请求要求授权、证书等，我们需要处理下面的代理方法，以提供相应的授权处理等\t\t\r\n\r\n```\r\nfunc webView(webView: WKWebView, didReceiveAuthenticationChallenge challenge: NSURLAuthenticationChallenge, completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void) {\r\n    print(__FUNCTION__)\r\n    completionHandler(.PerformDefaultHandling, nil)\r\n}\r\n```\r\n####网页与原生之前交互功能\r\n在webview的初始化方法的configuration中注入js交互对象，设置接口名称，和WKScriptMessageHandler的代理，这样就能实现网页和原生应用之间的交互功能\r\n\r\n```\r\nconf.userContentController.addScriptMessageHandler(self, name: \"MyInterface\")\r\n```\r\n####WKScriptMessageHandler 代理\t\t\r\n这里是实现响应事件的重要方法，交互逻辑主要通过该协议中方法实现。\t\r\n看看WKScriptMessageHandler，在js端通过window.webkit.messageHandlers.{InjectedName}.postMessage()方法来发送消息到native。我们需要遵守此协议，然后实现其代理方法，就可以收到消息，并做相应处理。postMessage()中可以传递字典类型的参数。\r\n\r\n```\r\nprivate typealias wkScriptMessageHandler = ViewController\r\n\r\nextension wkScriptMessageHandler : WKScriptMessageHandler{\r\n    \r\n    func userContentController(userContentController: WKUserContentController, didReceiveScriptMessage message: WKScriptMessage) {\r\n        \r\n        print(message.name)\r\n        print(message.body.description)\r\n        if message.name == \"MyInterface\" {\r\n            //TODO:\r\n    }\r\n}\r\n\r\n```\r\n####网页加载前后可注入js代码用来改变网页布局或其他功能\r\n\r\n```\r\nlet script = WKUserScript(source: scriptContent, injectionTime: .AtDocumentEnd, forMainFrameOnly: false)\r\nconf.userContentController.addUserScript(script)\r\n```\r\n* 可选择在网页加载前或加载后开始加载js代码\r\n\r\n###缓存清理\t\t\r\n长时间使用网页，缓存数据肯定是会有的，所以清理网页缓存也是常用的方法，缓存分为两种MemoryCache和DiskCache，一种存在手机内存中，一种存在app的沙盒文件中，ios9前wk没有提供清理缓存的系统方法，所以只能进行手动清理，即找到目标文件夹删除，所以可以两种方式都要考虑到\t\t\r\n\r\n\r\n```\r\n func cleanCaches() -> Void {\r\n        \r\n        if #available(iOS 9.0, *) {\r\n        ／／ios9.0之后清理缓存方法很简单\r\n            let websiteDataTypes = NSSet(array: [WKWebsiteDataTypeMemoryCache,WKWebsiteDataTypeDiskCache])\r\n            let date = NSDate(timeIntervalSince1970: 0)\r\n            WKWebsiteDataStore.defaultDataStore().removeDataOfTypes(websiteDataTypes as! Set<String>, modifiedSince: date, completionHandler:{})\r\n        }else{\r\n            //清理DiskCache,至于文件夹位置，可以去沙盒亲自看看    \r\n            if let docPath = NSSearchPathForDirectoriesInDomains(.LibraryDirectory, .UserDomainMask, true).first{\r\n                if let bundleId = NSBundle.mainBundle().infoDictionary![\"CFBundleIdentifier\"] as? String{\r\n      \t\t let webkitFolderInCaches = docPath + \"/Caches/\" + bundleId + \"/Webkit\"\r\n                    do{       \r\n                        try NSFileManager.defaultManager().removeItemAtPath(webkitFolderInCaches)\r\n                        \r\n                    }catch(let error){\r\n                        \r\n                        print(error)\r\n                    }\t\r\n                    \r\n\t\t//清理memoryCache  \t\r\n\t\t NSURLCache.sharedURLCache().removeAllCachedResponses()\r\n                }\r\n            }\r\n        }\r\n        \t\r\n    }\r\n\r\n```\r\n\r\n####计算网页diskCache的大小方法\t\t\r\n```\r\nextension String{\r\n    func caculateFileSize() -> UInt64 {\r\n        var size : UInt64 = 0\r\n        let manager = NSFileManager.defaultManager()\r\n        let exist = manager.fileExistsAtPath(self)\r\n        \r\n        guard exist else{\r\n            return size\r\n        }\r\n        //遍历该文件夹下所有文件包括子文件夹名称\r\n        if let enumerater = manager.enumeratorAtPath(self){\r\n            for subPath in enumerater {\r\n                let fullPath = self + \"/\" + (subPath as! String)\t\t\r\n                //判断文件是否为文件还是文件夹 false为文件，true为文件夹\r\n                var isDoc : ObjCBool = false\r\n                if manager.fileExistsAtPath(fullPath, isDirectory: &isDoc) {\r\n                    if !isDoc {\r\n                        do{\r\n                            if let attr : NSDictionary = try manager.attributesOfItemAtPath(fullPath) {\r\n                                size += attr.fileSize()\r\n                            }\r\n                            \r\n                        }catch(let error){\r\n                            print(error)\r\n                        }\r\n                    }\r\n                }\r\n                \r\n            }\r\n        }\r\n        return size / (1024 * 1024)\r\n    }\r\n}\r\n```\r\n我是给string加了一个扩展方法，找到缓存文件夹路径之后通过该方法返回size，至于NSFileManager的操作我也是借鉴了别人[精心整理的方法][id]，建议大家也可以去看看。\t\t\r\n[id]:http://www.hangge.com/blog/cache/detail_527.html\r\n\r\n\r\n###先写到这吧，后面再更新....\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}