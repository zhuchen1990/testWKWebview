<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>TestWKWebViewDemo by zhuchen1990</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">TestWKWebViewDemo</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/zhuchen1990/testWKWebview" class="btn">View on GitHub</a>
      <a href="https://github.com/zhuchen1990/testWKWebview/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/zhuchen1990/testWKWebview/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="mytest" class="anchor" href="#mytest" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MyTest</h1>

<p>This is a project that test the ThirdPlatform  APIs</p>

<ul>
<li>WKWebView</li>
<li>KingFisher</li>
<li>Chart</li>
</ul>

<h2>
<a id="wkwebview" class="anchor" href="#wkwebview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>WKWebView</h2>

<h3>
<a id="引言" class="anchor" href="#%E5%BC%95%E8%A8%80" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>引言</h3>

<p>说到WKWebView，自我感觉的确很强大，不仅加载速度提升了，与js交互功能也越来强大了，这里就来写写自己在使用过程中的一些心得</p>

<h3>
<a id="使用" class="anchor" href="#%E4%BD%BF%E7%94%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>使用</h3>

<p>使用过UIWebView的朋友对WkWebView的API应该也会比较熟悉，两者方法名很相似，苹果方面并没有改变太多，所以用起来也比较顺手,本人使用的是swift，下面代码也以swift为主。    </p>

<h4>
<a id="初始化" class="anchor" href="#%E5%88%9D%E5%A7%8B%E5%8C%96" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>初始化</h4>

<pre><code>let conf = WKWebViewConfiguration()
        wkWebView = WKWebView(frame: self.view.frame,configuration: conf)
        wkWebView.loadRequest(NSURLRequest(URL: NSURL(string: "http://www.baidu.com")!))
         wkWebView.UIDelegate = self
        wkWebView.navigationDelegate = self
        self.view.addSubview(wkWebView)

</code></pre>

<p>注意的有以下几点<br>
1. 这里设置了WKWebView两个重要的代理UIDelegate和navigationDelegate，前者处理网页上一些弹出框的显示样式，后者处理网页加载时的逻辑，页面导航等。<br>
2. WKWebView都有一个配置策略，WKWebViewConfiguration关系网页的js交互功能，后面将详细介绍</p>

<h4>
<a id="uidelegate" class="anchor" href="#uidelegate" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>UIDelegate</h4>

<pre><code>
func webView(webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: () -&gt; Void) {
        let av = UIAlertController(title: "alert", message: message, preferredStyle: .Alert)
        let ac = UIAlertAction(title: "sure", style: .Default) { (action) in
            completionHandler()
        }
        av.addAction(ac)
        self.presentViewController(av, animated: true, completion: nil)
    }

    func webView(webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: (Bool) -&gt; Void) {

        let av = UIAlertController(title: "confirm", message: message, preferredStyle: .Alert)
        let ac = UIAlertAction(title: "sure", style: .Default) { (action) in
            completionHandler(true)
        }
        let cancel = UIAlertAction(title: "cancel", style: .Cancel, handler: {(action) in
            completionHandler(false)
        })
        av.addAction(ac)
        av.addAction(cancel)
        self.presentViewController(av, animated: true, completion: nil)

    }

    func webView(webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: (String?) -&gt; Void) {
        let av = UIAlertController(title: "prompt", message: prompt, preferredStyle: .Alert)
        let ac = UIAlertAction(title: "sure", style: .Default) { (action) in
            let content = av.textFields?.first?.text
            completionHandler(content)
        }
        let cancel = UIAlertAction(title: "cancel", style: .Cancel, handler: {(action) in
            completionHandler(nil)
        })
        av.addTextFieldWithConfigurationHandler { (textField) in
            textField.text = defaultText
        }

        av.addAction(ac)
        av.addAction(cancel)
        self.presentViewController(av, animated: true, completion: nil)
    }
</code></pre>

<p>这几个方法不是必须实现的，如果实现了这些方法，表明网页如果调用一些弹出框的时候如：alert，confirm，prompt会以系统原生的样式进行显示。</p>

<h4>
<a id="wknavigationdelegate" class="anchor" href="#wknavigationdelegate" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>WKNavigationDelegate</h4>

<p>1.开始加载页面内容时就会回调此代理方法，与UIWebView的didStartLoad功能相当。   </p>

<pre><code>func webView(webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
    }
</code></pre>

<p>2.加载完成的回调 </p>

<pre><code>func webView(webView: WKWebView, didFinishNavigation navigation: WKNavigation!) {
        self.title = webView.title
    }
</code></pre>

<p>3.如果我们需要处理在重定向时       </p>

<pre><code>func webView(webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {
  print(__FUNCTION__)
}
</code></pre>

<p>4.我们终止页面加载  </p>

<pre><code>func webViewWebContentProcessDidTerminate(webView: WKWebView) {
    print(__FUNCTION__)
}
</code></pre>

<p>5.决定是否允许导航响应，如果不允许就不会跳转到该链接的页面。</p>

<pre><code>func webView(webView: WKWebView, decidePolicyForNavigationResponse navigationResponse: WKNavigationResponse, decisionHandler: (WKNavigationResponsePolicy) -&gt; Void) {
    print(__FUNCTION__)
    decisionHandler(.Allow)
}
</code></pre>

<p>6.如果我们的请求要求授权、证书等，我们需要处理下面的代理方法，以提供相应的授权处理等       </p>

<pre><code>func webView(webView: WKWebView, didReceiveAuthenticationChallenge challenge: NSURLAuthenticationChallenge, completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -&gt; Void) {
    print(__FUNCTION__)
    completionHandler(.PerformDefaultHandling, nil)
}
</code></pre>

<h4>
<a id="网页与原生之前交互功能" class="anchor" href="#%E7%BD%91%E9%A1%B5%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%B9%8B%E5%89%8D%E4%BA%A4%E4%BA%92%E5%8A%9F%E8%83%BD" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>网页与原生之前交互功能</h4>

<p>在webview的初始化方法的configuration中注入js交互对象，设置接口名称，和WKScriptMessageHandler的代理，这样就能实现网页和原生应用之间的交互功能</p>

<pre><code>conf.userContentController.addScriptMessageHandler(self, name: "MyInterface")
</code></pre>

<h4>
<a id="wkscriptmessagehandler-代理" class="anchor" href="#wkscriptmessagehandler-%E4%BB%A3%E7%90%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>WKScriptMessageHandler 代理</h4>

<p>这里是实现响应事件的重要方法，交互逻辑主要通过该协议中方法实现。<br>
看看WKScriptMessageHandler，在js端通过window.webkit.messageHandlers.{InjectedName}.postMessage()方法来发送消息到native。我们需要遵守此协议，然后实现其代理方法，就可以收到消息，并做相应处理。postMessage()中可以传递字典类型的参数。</p>

<pre><code>private typealias wkScriptMessageHandler = ViewController

extension wkScriptMessageHandler : WKScriptMessageHandler{

    func userContentController(userContentController: WKUserContentController, didReceiveScriptMessage message: WKScriptMessage) {

        print(message.name)
        print(message.body.description)
        if message.name == "MyInterface" {
            //TODO:
    }
}

</code></pre>

<h4>
<a id="网页加载前后可注入js代码用来改变网页布局或其他功能" class="anchor" href="#%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E5%89%8D%E5%90%8E%E5%8F%AF%E6%B3%A8%E5%85%A5js%E4%BB%A3%E7%A0%81%E7%94%A8%E6%9D%A5%E6%94%B9%E5%8F%98%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%88%96%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>网页加载前后可注入js代码用来改变网页布局或其他功能</h4>

<pre><code>let script = WKUserScript(source: scriptContent, injectionTime: .AtDocumentEnd, forMainFrameOnly: false)
conf.userContentController.addUserScript(script)
</code></pre>

<ul>
<li>可选择在网页加载前或加载后开始加载js代码</li>
</ul>

<h3>
<a id="缓存清理" class="anchor" href="#%E7%BC%93%E5%AD%98%E6%B8%85%E7%90%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>缓存清理</h3>

<p>长时间使用网页，缓存数据肯定是会有的，所以清理网页缓存也是常用的方法，缓存分为两种MemoryCache和DiskCache，一种存在手机内存中，一种存在app的沙盒文件中，ios9前wk没有提供清理缓存的系统方法，所以只能进行手动清理，即找到目标文件夹删除，所以可以两种方式都要考虑到     </p>

<pre><code> func cleanCaches() -&gt; Void {

        if #available(iOS 9.0, *) {
        ／／ios9.0之后清理缓存方法很简单
            let websiteDataTypes = NSSet(array: [WKWebsiteDataTypeMemoryCache,WKWebsiteDataTypeDiskCache])
            let date = NSDate(timeIntervalSince1970: 0)
            WKWebsiteDataStore.defaultDataStore().removeDataOfTypes(websiteDataTypes as! Set&lt;String&gt;, modifiedSince: date, completionHandler:{})
        }else{
            //清理DiskCache,至于文件夹位置，可以去沙盒亲自看看    
            if let docPath = NSSearchPathForDirectoriesInDomains(.LibraryDirectory, .UserDomainMask, true).first{
                if let bundleId = NSBundle.mainBundle().infoDictionary!["CFBundleIdentifier"] as? String{
             let webkitFolderInCaches = docPath + "/Caches/" + bundleId + "/Webkit"
                    do{       
                        try NSFileManager.defaultManager().removeItemAtPath(webkitFolderInCaches)

                    }catch(let error){

                        print(error)
                    }   

        //清理memoryCache     
         NSURLCache.sharedURLCache().removeAllCachedResponses()
                }
            }
        }

    }

</code></pre>

<h4>
<a id="计算网页diskcache的大小方法" class="anchor" href="#%E8%AE%A1%E7%AE%97%E7%BD%91%E9%A1%B5diskcache%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%96%B9%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>计算网页diskCache的大小方法</h4>

<pre><code>extension String{
    func caculateFileSize() -&gt; UInt64 {
        var size : UInt64 = 0
        let manager = NSFileManager.defaultManager()
        let exist = manager.fileExistsAtPath(self)

        guard exist else{
            return size
        }
        //遍历该文件夹下所有文件包括子文件夹名称
        if let enumerater = manager.enumeratorAtPath(self){
            for subPath in enumerater {
                let fullPath = self + "/" + (subPath as! String)        
                //判断文件是否为文件还是文件夹 false为文件，true为文件夹
                var isDoc : ObjCBool = false
                if manager.fileExistsAtPath(fullPath, isDirectory: &amp;isDoc) {
                    if !isDoc {
                        do{
                            if let attr : NSDictionary = try manager.attributesOfItemAtPath(fullPath) {
                                size += attr.fileSize()
                            }

                        }catch(let error){
                            print(error)
                        }
                    }
                }

            }
        }
        return size / (1024 * 1024)
    }
}
</code></pre>

<p>我是给string加了一个扩展方法，找到缓存文件夹路径之后通过该方法返回size，至于NSFileManager的操作我也是借鉴了别人<a href="http://www.hangge.com/blog/cache/detail_527.html">精心整理的方法</a>，建议大家也可以去看看。      </p>

<h3>
<a id="先写到这吧后面再更新" class="anchor" href="#%E5%85%88%E5%86%99%E5%88%B0%E8%BF%99%E5%90%A7%E5%90%8E%E9%9D%A2%E5%86%8D%E6%9B%B4%E6%96%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>先写到这吧，后面再更新....</h3>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/zhuchen1990/testWKWebview">TestWKWebViewDemo</a> is maintained by <a href="https://github.com/zhuchen1990">zhuchen1990</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
